{
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "DAST-Scanner",
          "rules": [
            {
              "id": "8659F9303BF3A26B84B2125B88AB7E15",
              "name": "Server Error",
              "fullDescription": {
                "text": "Information Leakage is an application weakness where an application reveals sensitive data, such as technical details of the web application, environment, \n    or user-specific data. Sensitive data may be used by an attacker to exploit the target web application, its hosting network, or its users. \n    Therefore, leakage of sensitive data should be limited or prevented whenever possible. Information Leakage, in its most common form, \n    is the result of one or more of the following conditions: \n    - A failure to scrub out HTML/Script comments containing sensitive information\n    - Improper application or server configurations\n    - Differences in page responses for valid versus invalid data.\n\n    A 5XX response code was detected.\n\n    Improper handling of errors can introduce a variety of security problems for a web site. The most common problem is when detailed internal error messages such as stack traces, database dumps, and error codes are displayed to the user (hacker). \n    These messages reveal implementation details that should never be revealed. Such details can provide hackers important clues on potential flaws in the site and such messages are also disturbing to normal users.\n\n    Web applications frequently generate error conditions during normal operation. Out of memory, null pointer exceptions, system call failure, database unavailable, network timeout,and hundreds of other common conditions can cause errors to be generated.\n    These errors must be handled according to a well thought out scheme that will provide a meaningful error message to the user, diagnostic information to the site maintainers, and no useful information to an attacker.\r\n\r\n\n\n**References:**\n\n\n* [OWASP: Improper Error Handling](https://owasp.org/www-community/Improper_Error_Handling)\n* [OWASP WSTG: Testing for Improper Error Handling](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/08-Testing_for_Error_Handling/01-Testing_For_Improper_Error_Handling)"
              }
            },
            {
              "id": "5387BD05073049EE934D84458C86FACE",
              "name": "Server Error",
              "fullDescription": {
                "text": "Information Leakage is an application weakness where an application reveals sensitive data, such as technical details of the web application, environment, \n    or user-specific data. Sensitive data may be used by an attacker to exploit the target web application, its hosting network, or its users. \n    Therefore, leakage of sensitive data should be limited or prevented whenever possible. Information Leakage, in its most common form, \n    is the result of one or more of the following conditions: \n    - A failure to scrub out HTML/Script comments containing sensitive information\n    - Improper application or server configurations\n    - Differences in page responses for valid versus invalid data.\n\n    A 5XX response code was detected.\n\n    Improper handling of errors can introduce a variety of security problems for a web site. The most common problem is when detailed internal error messages such as stack traces, database dumps, and error codes are displayed to the user (hacker). \n    These messages reveal implementation details that should never be revealed. Such details can provide hackers important clues on potential flaws in the site and such messages are also disturbing to normal users.\n\n    Web applications frequently generate error conditions during normal operation. Out of memory, null pointer exceptions, system call failure, database unavailable, network timeout,and hundreds of other common conditions can cause errors to be generated.\n    These errors must be handled according to a well thought out scheme that will provide a meaningful error message to the user, diagnostic information to the site maintainers, and no useful information to an attacker.\r\n\r\n\n\n**References:**\n\n\n* [OWASP: Improper Error Handling](https://owasp.org/www-community/Improper_Error_Handling)\n* [OWASP WSTG: Testing for Improper Error Handling](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/08-Testing_for_Error_Handling/01-Testing_For_Improper_Error_Handling)"
              }
            },
            {
              "id": "FF9BABE97447B17D042D69FABAB72F98",
              "name": "Server Error",
              "fullDescription": {
                "text": "Information Leakage is an application weakness where an application reveals sensitive data, such as technical details of the web application, environment, \n    or user-specific data. Sensitive data may be used by an attacker to exploit the target web application, its hosting network, or its users. \n    Therefore, leakage of sensitive data should be limited or prevented whenever possible. Information Leakage, in its most common form, \n    is the result of one or more of the following conditions: \n    - A failure to scrub out HTML/Script comments containing sensitive information\n    - Improper application or server configurations\n    - Differences in page responses for valid versus invalid data.\n\n    A 5XX response code was detected.\n\n    Improper handling of errors can introduce a variety of security problems for a web site. The most common problem is when detailed internal error messages such as stack traces, database dumps, and error codes are displayed to the user (hacker). \n    These messages reveal implementation details that should never be revealed. Such details can provide hackers important clues on potential flaws in the site and such messages are also disturbing to normal users.\n\n    Web applications frequently generate error conditions during normal operation. Out of memory, null pointer exceptions, system call failure, database unavailable, network timeout,and hundreds of other common conditions can cause errors to be generated.\n    These errors must be handled according to a well thought out scheme that will provide a meaningful error message to the user, diagnostic information to the site maintainers, and no useful information to an attacker.\r\n\r\n\n\n**References:**\n\n\n* [OWASP: Improper Error Handling](https://owasp.org/www-community/Improper_Error_Handling)\n* [OWASP WSTG: Testing for Improper Error Handling](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/08-Testing_for_Error_Handling/01-Testing_For_Improper_Error_Handling)"
              }
            },
            {
              "id": "46E6C6A03B55651B27596E1C842ED038",
              "name": "Server Error",
              "fullDescription": {
                "text": "Information Leakage is an application weakness where an application reveals sensitive data, such as technical details of the web application, environment, \n    or user-specific data. Sensitive data may be used by an attacker to exploit the target web application, its hosting network, or its users. \n    Therefore, leakage of sensitive data should be limited or prevented whenever possible. Information Leakage, in its most common form, \n    is the result of one or more of the following conditions: \n    - A failure to scrub out HTML/Script comments containing sensitive information\n    - Improper application or server configurations\n    - Differences in page responses for valid versus invalid data.\n\n    A 5XX response code was detected.\n\n    Improper handling of errors can introduce a variety of security problems for a web site. The most common problem is when detailed internal error messages such as stack traces, database dumps, and error codes are displayed to the user (hacker). \n    These messages reveal implementation details that should never be revealed. Such details can provide hackers important clues on potential flaws in the site and such messages are also disturbing to normal users.\n\n    Web applications frequently generate error conditions during normal operation. Out of memory, null pointer exceptions, system call failure, database unavailable, network timeout,and hundreds of other common conditions can cause errors to be generated.\n    These errors must be handled according to a well thought out scheme that will provide a meaningful error message to the user, diagnostic information to the site maintainers, and no useful information to an attacker.\r\n\r\n\n\n**References:**\n\n\n* [OWASP: Improper Error Handling](https://owasp.org/www-community/Improper_Error_Handling)\n* [OWASP WSTG: Testing for Improper Error Handling](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/08-Testing_for_Error_Handling/01-Testing_For_Improper_Error_Handling)"
              }
            },
            {
              "id": "2FC5500043A886DBF8B1B080CCC44840",
              "name": "Server Error",
              "fullDescription": {
                "text": "Information Leakage is an application weakness where an application reveals sensitive data, such as technical details of the web application, environment, \n    or user-specific data. Sensitive data may be used by an attacker to exploit the target web application, its hosting network, or its users. \n    Therefore, leakage of sensitive data should be limited or prevented whenever possible. Information Leakage, in its most common form, \n    is the result of one or more of the following conditions: \n    - A failure to scrub out HTML/Script comments containing sensitive information\n    - Improper application or server configurations\n    - Differences in page responses for valid versus invalid data.\n\n    A 5XX response code was detected.\n\n    Improper handling of errors can introduce a variety of security problems for a web site. The most common problem is when detailed internal error messages such as stack traces, database dumps, and error codes are displayed to the user (hacker). \n    These messages reveal implementation details that should never be revealed. Such details can provide hackers important clues on potential flaws in the site and such messages are also disturbing to normal users.\n\n    Web applications frequently generate error conditions during normal operation. Out of memory, null pointer exceptions, system call failure, database unavailable, network timeout,and hundreds of other common conditions can cause errors to be generated.\n    These errors must be handled according to a well thought out scheme that will provide a meaningful error message to the user, diagnostic information to the site maintainers, and no useful information to an attacker.\r\n\r\n\n\n**References:**\n\n\n* [OWASP: Improper Error Handling](https://owasp.org/www-community/Improper_Error_Handling)\n* [OWASP WSTG: Testing for Improper Error Handling](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/08-Testing_for_Error_Handling/01-Testing_For_Improper_Error_Handling)"
              }
            },
            {
              "id": "CCF5F89C41264FC7E6B90B93478BC8F0",
              "name": "Server Error",
              "fullDescription": {
                "text": "Information Leakage is an application weakness where an application reveals sensitive data, such as technical details of the web application, environment, \n    or user-specific data. Sensitive data may be used by an attacker to exploit the target web application, its hosting network, or its users. \n    Therefore, leakage of sensitive data should be limited or prevented whenever possible. Information Leakage, in its most common form, \n    is the result of one or more of the following conditions: \n    - A failure to scrub out HTML/Script comments containing sensitive information\n    - Improper application or server configurations\n    - Differences in page responses for valid versus invalid data.\n\n    A 5XX response code was detected.\n\n    Improper handling of errors can introduce a variety of security problems for a web site. The most common problem is when detailed internal error messages such as stack traces, database dumps, and error codes are displayed to the user (hacker). \n    These messages reveal implementation details that should never be revealed. Such details can provide hackers important clues on potential flaws in the site and such messages are also disturbing to normal users.\n\n    Web applications frequently generate error conditions during normal operation. Out of memory, null pointer exceptions, system call failure, database unavailable, network timeout,and hundreds of other common conditions can cause errors to be generated.\n    These errors must be handled according to a well thought out scheme that will provide a meaningful error message to the user, diagnostic information to the site maintainers, and no useful information to an attacker.\r\n\r\n\n\n**References:**\n\n\n* [OWASP: Improper Error Handling](https://owasp.org/www-community/Improper_Error_Handling)\n* [OWASP WSTG: Testing for Improper Error Handling](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/08-Testing_for_Error_Handling/01-Testing_For_Improper_Error_Handling)"
              }
            },
            {
              "id": "BC00609D0BE528FC84DDD93E823A0FC8",
              "name": "Server Error",
              "fullDescription": {
                "text": "Information Leakage is an application weakness where an application reveals sensitive data, such as technical details of the web application, environment, \n    or user-specific data. Sensitive data may be used by an attacker to exploit the target web application, its hosting network, or its users. \n    Therefore, leakage of sensitive data should be limited or prevented whenever possible. Information Leakage, in its most common form, \n    is the result of one or more of the following conditions: \n    - A failure to scrub out HTML/Script comments containing sensitive information\n    - Improper application or server configurations\n    - Differences in page responses for valid versus invalid data.\n\n    A 5XX response code was detected.\n\n    Improper handling of errors can introduce a variety of security problems for a web site. The most common problem is when detailed internal error messages such as stack traces, database dumps, and error codes are displayed to the user (hacker). \n    These messages reveal implementation details that should never be revealed. Such details can provide hackers important clues on potential flaws in the site and such messages are also disturbing to normal users.\n\n    Web applications frequently generate error conditions during normal operation. Out of memory, null pointer exceptions, system call failure, database unavailable, network timeout,and hundreds of other common conditions can cause errors to be generated.\n    These errors must be handled according to a well thought out scheme that will provide a meaningful error message to the user, diagnostic information to the site maintainers, and no useful information to an attacker.\r\n\r\n\n\n**References:**\n\n\n* [OWASP: Improper Error Handling](https://owasp.org/www-community/Improper_Error_Handling)\n* [OWASP WSTG: Testing for Improper Error Handling](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/08-Testing_for_Error_Handling/01-Testing_For_Improper_Error_Handling)"
              }
            },
            {
              "id": "737CCF4C6EB5A0AA41041ED8A67594BE",
              "name": "Server Error",
              "fullDescription": {
                "text": "Information Leakage is an application weakness where an application reveals sensitive data, such as technical details of the web application, environment, \n    or user-specific data. Sensitive data may be used by an attacker to exploit the target web application, its hosting network, or its users. \n    Therefore, leakage of sensitive data should be limited or prevented whenever possible. Information Leakage, in its most common form, \n    is the result of one or more of the following conditions: \n    - A failure to scrub out HTML/Script comments containing sensitive information\n    - Improper application or server configurations\n    - Differences in page responses for valid versus invalid data.\n\n    A 5XX response code was detected.\n\n    Improper handling of errors can introduce a variety of security problems for a web site. The most common problem is when detailed internal error messages such as stack traces, database dumps, and error codes are displayed to the user (hacker). \n    These messages reveal implementation details that should never be revealed. Such details can provide hackers important clues on potential flaws in the site and such messages are also disturbing to normal users.\n\n    Web applications frequently generate error conditions during normal operation. Out of memory, null pointer exceptions, system call failure, database unavailable, network timeout,and hundreds of other common conditions can cause errors to be generated.\n    These errors must be handled according to a well thought out scheme that will provide a meaningful error message to the user, diagnostic information to the site maintainers, and no useful information to an attacker.\r\n\r\n\n\n**References:**\n\n\n* [OWASP: Improper Error Handling](https://owasp.org/www-community/Improper_Error_Handling)\n* [OWASP WSTG: Testing for Improper Error Handling](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/08-Testing_for_Error_Handling/01-Testing_For_Improper_Error_Handling)"
              }
            },
            {
              "id": "49502AD3CBA2EBFE782B08B5DFCD523B",
              "name": "Server Error",
              "fullDescription": {
                "text": "Information Leakage is an application weakness where an application reveals sensitive data, such as technical details of the web application, environment, \n    or user-specific data. Sensitive data may be used by an attacker to exploit the target web application, its hosting network, or its users. \n    Therefore, leakage of sensitive data should be limited or prevented whenever possible. Information Leakage, in its most common form, \n    is the result of one or more of the following conditions: \n    - A failure to scrub out HTML/Script comments containing sensitive information\n    - Improper application or server configurations\n    - Differences in page responses for valid versus invalid data.\n\n    A 5XX response code was detected.\n\n    Improper handling of errors can introduce a variety of security problems for a web site. The most common problem is when detailed internal error messages such as stack traces, database dumps, and error codes are displayed to the user (hacker). \n    These messages reveal implementation details that should never be revealed. Such details can provide hackers important clues on potential flaws in the site and such messages are also disturbing to normal users.\n\n    Web applications frequently generate error conditions during normal operation. Out of memory, null pointer exceptions, system call failure, database unavailable, network timeout,and hundreds of other common conditions can cause errors to be generated.\n    These errors must be handled according to a well thought out scheme that will provide a meaningful error message to the user, diagnostic information to the site maintainers, and no useful information to an attacker.\r\n\r\n\n\n**References:**\n\n\n* [OWASP: Improper Error Handling](https://owasp.org/www-community/Improper_Error_Handling)\n* [OWASP WSTG: Testing for Improper Error Handling](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/08-Testing_for_Error_Handling/01-Testing_For_Improper_Error_Handling)"
              }
            },
            {
              "id": "461F27419D71D8D4054D4647D01C82B1",
              "name": "Server Error",
              "fullDescription": {
                "text": "Information Leakage is an application weakness where an application reveals sensitive data, such as technical details of the web application, environment, \n    or user-specific data. Sensitive data may be used by an attacker to exploit the target web application, its hosting network, or its users. \n    Therefore, leakage of sensitive data should be limited or prevented whenever possible. Information Leakage, in its most common form, \n    is the result of one or more of the following conditions: \n    - A failure to scrub out HTML/Script comments containing sensitive information\n    - Improper application or server configurations\n    - Differences in page responses for valid versus invalid data.\n\n    A 5XX response code was detected.\n\n    Improper handling of errors can introduce a variety of security problems for a web site. The most common problem is when detailed internal error messages such as stack traces, database dumps, and error codes are displayed to the user (hacker). \n    These messages reveal implementation details that should never be revealed. Such details can provide hackers important clues on potential flaws in the site and such messages are also disturbing to normal users.\n\n    Web applications frequently generate error conditions during normal operation. Out of memory, null pointer exceptions, system call failure, database unavailable, network timeout,and hundreds of other common conditions can cause errors to be generated.\n    These errors must be handled according to a well thought out scheme that will provide a meaningful error message to the user, diagnostic information to the site maintainers, and no useful information to an attacker.\r\n\r\n\n\n**References:**\n\n\n* [OWASP: Improper Error Handling](https://owasp.org/www-community/Improper_Error_Handling)\n* [OWASP WSTG: Testing for Improper Error Handling](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/08-Testing_for_Error_Handling/01-Testing_For_Improper_Error_Handling)"
              }
            },
            {
              "id": "A241AF41BB63C7D95A0CA2C6334EA4E7",
              "name": "Server Error",
              "fullDescription": {
                "text": "Information Leakage is an application weakness where an application reveals sensitive data, such as technical details of the web application, environment, \n    or user-specific data. Sensitive data may be used by an attacker to exploit the target web application, its hosting network, or its users. \n    Therefore, leakage of sensitive data should be limited or prevented whenever possible. Information Leakage, in its most common form, \n    is the result of one or more of the following conditions: \n    - A failure to scrub out HTML/Script comments containing sensitive information\n    - Improper application or server configurations\n    - Differences in page responses for valid versus invalid data.\n\n    A 5XX response code was detected.\n\n    Improper handling of errors can introduce a variety of security problems for a web site. The most common problem is when detailed internal error messages such as stack traces, database dumps, and error codes are displayed to the user (hacker). \n    These messages reveal implementation details that should never be revealed. Such details can provide hackers important clues on potential flaws in the site and such messages are also disturbing to normal users.\n\n    Web applications frequently generate error conditions during normal operation. Out of memory, null pointer exceptions, system call failure, database unavailable, network timeout,and hundreds of other common conditions can cause errors to be generated.\n    These errors must be handled according to a well thought out scheme that will provide a meaningful error message to the user, diagnostic information to the site maintainers, and no useful information to an attacker.\r\n\r\n\n\n**References:**\n\n\n* [OWASP: Improper Error Handling](https://owasp.org/www-community/Improper_Error_Handling)\n* [OWASP WSTG: Testing for Improper Error Handling](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/08-Testing_for_Error_Handling/01-Testing_For_Improper_Error_Handling)"
              }
            },
            {
              "id": "94F6BE4EC7EBBF0BDF36FEB351AA1E80",
              "name": "Unsecured Session Cookie",
              "fullDescription": {
                "text": "The application fails to set the 'Secure' attribute on one or more cookies, which exposes them to attacks on insecure network communication. If the 'Secure' attribute is set on a cookie, the browser sends the cookie over encrypted HTTPS connections, and not over HTTP. The 'Secure' attribute helps prevent cookies from being stolen by attackers on the same network as victims; cookies without this attribute can be stolen.\n\nIf this attribute is not set, the browser sends the cookie to the vulnerable site along with all HTTP requests to that site. An attacker that can sniff traffic between the victim and the server can steal the sensitive cookies.\n\nThe 'Secure' attribute needs to be set even if the vulnerable site only serves content over HTTPS and does not listen for HTTP traffic. An attacker on the same LAN as the victim can inject arbitrary content into any page from another site that is served over plain-text HTTP. For example, an attacker can inject content such as the following into any plain-text HTTP response:\n\n```\n<img src=\"http://vulnerable.example.com/\">\n```\n\nThe victim's browser sends a plain-text HTTP request for http://vulnerable.example.com/, including the victim's cookie, which can be compromised by a man-in-the-middle attacker as the data is sent unencrypted.\r\n\r\nIf the 'Secure' attribute is not set on a cookie, the cookie may be sent over unencrypted connections and can be stolen by an attacker with access to the network path. If the cookie contains the victim's session identifier, then the attacker can steal the victim's session.\n\n**References:**\n\n\n* [Secure Cookie Attribute](https://owasp.org/www-community/controls/SecureCookieAttribute)"
              }
            },
            {
              "id": "133F8F76E8634046ABA74703C85D3FFD",
              "name": "Stack Trace",
              "fullDescription": {
                "text": "The application generates error messages that include stack traces, which can reveal details about the application's implementation. Stack traces are typically provided by the environment when an application reaches an erroneous state and are used by developers as well as administrators to debug issues. As such, stack traces contain information about all of the open stack frames relating to and leading to the error. They typically include, but are not limited to, function names, parameters, the memory addresses of relevant data, line numbers in code, and class names.\r\n\r\nError messages that contain stack traces reveal application implementation and error condition details to end users. This may include (but is not limited to) information about application architecture and implementation, error conditions, and any third-party libraries in use. In addition, certain languages, such as Java and C#, allow the developer to customize the error messages printed with stack traces. These custom errors may leak additional information since custom errors can include a wide variety of additional information, such as personally identifiable information (PII), connection strings, and request parameters. All this information is useful to an attacker seeking to develop more efficient, targeted attacks against the application.\n\n**References:**\n\n\n* [OWASP: Improper Error Handling](https://owasp.org/www-community/Improper_Error_Handling)\n* [OWASP WSTG: Testing for Improper Error Handling](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/08-Testing_for_Error_Handling/01-Testing_For_Improper_Error_Handling)"
              }
            },
            {
              "id": "334C00D2DF14756377256A0990249A24",
              "name": "Stack Trace",
              "fullDescription": {
                "text": "The application generates error messages that include stack traces, which can reveal details about the application's implementation. Stack traces are typically provided by the environment when an application reaches an erroneous state and are used by developers as well as administrators to debug issues. As such, stack traces contain information about all of the open stack frames relating to and leading to the error. They typically include, but are not limited to, function names, parameters, the memory addresses of relevant data, line numbers in code, and class names.\r\n\r\nError messages that contain stack traces reveal application implementation and error condition details to end users. This may include (but is not limited to) information about application architecture and implementation, error conditions, and any third-party libraries in use. In addition, certain languages, such as Java and C#, allow the developer to customize the error messages printed with stack traces. These custom errors may leak additional information since custom errors can include a wide variety of additional information, such as personally identifiable information (PII), connection strings, and request parameters. All this information is useful to an attacker seeking to develop more efficient, targeted attacks against the application.\n\n**References:**\n\n\n* [OWASP: Improper Error Handling](https://owasp.org/www-community/Improper_Error_Handling)\n* [OWASP WSTG: Testing for Improper Error Handling](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/08-Testing_for_Error_Handling/01-Testing_For_Improper_Error_Handling)"
              }
            },
            {
              "id": "F3585F038F1CD7E175C560C461A89584",
              "name": "Stack Trace",
              "fullDescription": {
                "text": "The application generates error messages that include stack traces, which can reveal details about the application's implementation. Stack traces are typically provided by the environment when an application reaches an erroneous state and are used by developers as well as administrators to debug issues. As such, stack traces contain information about all of the open stack frames relating to and leading to the error. They typically include, but are not limited to, function names, parameters, the memory addresses of relevant data, line numbers in code, and class names.\r\n\r\nError messages that contain stack traces reveal application implementation and error condition details to end users. This may include (but is not limited to) information about application architecture and implementation, error conditions, and any third-party libraries in use. In addition, certain languages, such as Java and C#, allow the developer to customize the error messages printed with stack traces. These custom errors may leak additional information since custom errors can include a wide variety of additional information, such as personally identifiable information (PII), connection strings, and request parameters. All this information is useful to an attacker seeking to develop more efficient, targeted attacks against the application.\n\n**References:**\n\n\n* [OWASP: Improper Error Handling](https://owasp.org/www-community/Improper_Error_Handling)\n* [OWASP WSTG: Testing for Improper Error Handling](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/08-Testing_for_Error_Handling/01-Testing_For_Improper_Error_Handling)"
              }
            },
            {
              "id": "2547662566BA8B63EE673062D14971CC",
              "name": "Stack Trace",
              "fullDescription": {
                "text": "The application generates error messages that include stack traces, which can reveal details about the application's implementation. Stack traces are typically provided by the environment when an application reaches an erroneous state and are used by developers as well as administrators to debug issues. As such, stack traces contain information about all of the open stack frames relating to and leading to the error. They typically include, but are not limited to, function names, parameters, the memory addresses of relevant data, line numbers in code, and class names.\r\n\r\nError messages that contain stack traces reveal application implementation and error condition details to end users. This may include (but is not limited to) information about application architecture and implementation, error conditions, and any third-party libraries in use. In addition, certain languages, such as Java and C#, allow the developer to customize the error messages printed with stack traces. These custom errors may leak additional information since custom errors can include a wide variety of additional information, such as personally identifiable information (PII), connection strings, and request parameters. All this information is useful to an attacker seeking to develop more efficient, targeted attacks against the application.\n\n**References:**\n\n\n* [OWASP: Improper Error Handling](https://owasp.org/www-community/Improper_Error_Handling)\n* [OWASP WSTG: Testing for Improper Error Handling](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/08-Testing_for_Error_Handling/01-Testing_For_Improper_Error_Handling)"
              }
            },
            {
              "id": "7B0E93A5E9883BE9BC15BA87AEB25B1B",
              "name": "Stack Trace",
              "fullDescription": {
                "text": "The application generates error messages that include stack traces, which can reveal details about the application's implementation. Stack traces are typically provided by the environment when an application reaches an erroneous state and are used by developers as well as administrators to debug issues. As such, stack traces contain information about all of the open stack frames relating to and leading to the error. They typically include, but are not limited to, function names, parameters, the memory addresses of relevant data, line numbers in code, and class names.\r\n\r\nError messages that contain stack traces reveal application implementation and error condition details to end users. This may include (but is not limited to) information about application architecture and implementation, error conditions, and any third-party libraries in use. In addition, certain languages, such as Java and C#, allow the developer to customize the error messages printed with stack traces. These custom errors may leak additional information since custom errors can include a wide variety of additional information, such as personally identifiable information (PII), connection strings, and request parameters. All this information is useful to an attacker seeking to develop more efficient, targeted attacks against the application.\n\n**References:**\n\n\n* [OWASP: Improper Error Handling](https://owasp.org/www-community/Improper_Error_Handling)\n* [OWASP WSTG: Testing for Improper Error Handling](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/08-Testing_for_Error_Handling/01-Testing_For_Improper_Error_Handling)"
              }
            },
            {
              "id": "9231792F8ECE81D8B78F7A09DFA96F3D",
              "name": "Stack Trace",
              "fullDescription": {
                "text": "The application generates error messages that include stack traces, which can reveal details about the application's implementation. Stack traces are typically provided by the environment when an application reaches an erroneous state and are used by developers as well as administrators to debug issues. As such, stack traces contain information about all of the open stack frames relating to and leading to the error. They typically include, but are not limited to, function names, parameters, the memory addresses of relevant data, line numbers in code, and class names.\r\n\r\nError messages that contain stack traces reveal application implementation and error condition details to end users. This may include (but is not limited to) information about application architecture and implementation, error conditions, and any third-party libraries in use. In addition, certain languages, such as Java and C#, allow the developer to customize the error messages printed with stack traces. These custom errors may leak additional information since custom errors can include a wide variety of additional information, such as personally identifiable information (PII), connection strings, and request parameters. All this information is useful to an attacker seeking to develop more efficient, targeted attacks against the application.\n\n**References:**\n\n\n* [OWASP: Improper Error Handling](https://owasp.org/www-community/Improper_Error_Handling)\n* [OWASP WSTG: Testing for Improper Error Handling](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/08-Testing_for_Error_Handling/01-Testing_For_Improper_Error_Handling)"
              }
            },
            {
              "id": "7BA471E8EF7FC63AFF751C76CCFC53FA",
              "name": "Stack Trace",
              "fullDescription": {
                "text": "The application generates error messages that include stack traces, which can reveal details about the application's implementation. Stack traces are typically provided by the environment when an application reaches an erroneous state and are used by developers as well as administrators to debug issues. As such, stack traces contain information about all of the open stack frames relating to and leading to the error. They typically include, but are not limited to, function names, parameters, the memory addresses of relevant data, line numbers in code, and class names.\r\n\r\nError messages that contain stack traces reveal application implementation and error condition details to end users. This may include (but is not limited to) information about application architecture and implementation, error conditions, and any third-party libraries in use. In addition, certain languages, such as Java and C#, allow the developer to customize the error messages printed with stack traces. These custom errors may leak additional information since custom errors can include a wide variety of additional information, such as personally identifiable information (PII), connection strings, and request parameters. All this information is useful to an attacker seeking to develop more efficient, targeted attacks against the application.\n\n**References:**\n\n\n* [OWASP: Improper Error Handling](https://owasp.org/www-community/Improper_Error_Handling)\n* [OWASP WSTG: Testing for Improper Error Handling](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/08-Testing_for_Error_Handling/01-Testing_For_Improper_Error_Handling)"
              }
            },
            {
              "id": "944A936F1301AD0362E35CFC80912D37",
              "name": "Stack Trace",
              "fullDescription": {
                "text": "The application generates error messages that include stack traces, which can reveal details about the application's implementation. Stack traces are typically provided by the environment when an application reaches an erroneous state and are used by developers as well as administrators to debug issues. As such, stack traces contain information about all of the open stack frames relating to and leading to the error. They typically include, but are not limited to, function names, parameters, the memory addresses of relevant data, line numbers in code, and class names.\r\n\r\nError messages that contain stack traces reveal application implementation and error condition details to end users. This may include (but is not limited to) information about application architecture and implementation, error conditions, and any third-party libraries in use. In addition, certain languages, such as Java and C#, allow the developer to customize the error messages printed with stack traces. These custom errors may leak additional information since custom errors can include a wide variety of additional information, such as personally identifiable information (PII), connection strings, and request parameters. All this information is useful to an attacker seeking to develop more efficient, targeted attacks against the application.\n\n**References:**\n\n\n* [OWASP: Improper Error Handling](https://owasp.org/www-community/Improper_Error_Handling)\n* [OWASP WSTG: Testing for Improper Error Handling](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/08-Testing_for_Error_Handling/01-Testing_For_Improper_Error_Handling)"
              }
            },
            {
              "id": "E2FFF487F311D91C720DB1BD8D127606",
              "name": "Stack Trace",
              "fullDescription": {
                "text": "The application generates error messages that include stack traces, which can reveal details about the application's implementation. Stack traces are typically provided by the environment when an application reaches an erroneous state and are used by developers as well as administrators to debug issues. As such, stack traces contain information about all of the open stack frames relating to and leading to the error. They typically include, but are not limited to, function names, parameters, the memory addresses of relevant data, line numbers in code, and class names.\r\n\r\nError messages that contain stack traces reveal application implementation and error condition details to end users. This may include (but is not limited to) information about application architecture and implementation, error conditions, and any third-party libraries in use. In addition, certain languages, such as Java and C#, allow the developer to customize the error messages printed with stack traces. These custom errors may leak additional information since custom errors can include a wide variety of additional information, such as personally identifiable information (PII), connection strings, and request parameters. All this information is useful to an attacker seeking to develop more efficient, targeted attacks against the application.\n\n**References:**\n\n\n* [OWASP: Improper Error Handling](https://owasp.org/www-community/Improper_Error_Handling)\n* [OWASP WSTG: Testing for Improper Error Handling](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/08-Testing_for_Error_Handling/01-Testing_For_Improper_Error_Handling)"
              }
            },
            {
              "id": "9995B9A075EB74E42F5D3D7CACA57B66",
              "name": "Stack Trace",
              "fullDescription": {
                "text": "The application generates error messages that include stack traces, which can reveal details about the application's implementation. Stack traces are typically provided by the environment when an application reaches an erroneous state and are used by developers as well as administrators to debug issues. As such, stack traces contain information about all of the open stack frames relating to and leading to the error. They typically include, but are not limited to, function names, parameters, the memory addresses of relevant data, line numbers in code, and class names.\r\n\r\nError messages that contain stack traces reveal application implementation and error condition details to end users. This may include (but is not limited to) information about application architecture and implementation, error conditions, and any third-party libraries in use. In addition, certain languages, such as Java and C#, allow the developer to customize the error messages printed with stack traces. These custom errors may leak additional information since custom errors can include a wide variety of additional information, such as personally identifiable information (PII), connection strings, and request parameters. All this information is useful to an attacker seeking to develop more efficient, targeted attacks against the application.\n\n**References:**\n\n\n* [OWASP: Improper Error Handling](https://owasp.org/www-community/Improper_Error_Handling)\n* [OWASP WSTG: Testing for Improper Error Handling](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/08-Testing_for_Error_Handling/01-Testing_For_Improper_Error_Handling)"
              }
            },
            {
              "id": "17FAAABBDCA4CF51EB3672F162980566",
              "name": "Stack Trace",
              "fullDescription": {
                "text": "The application generates error messages that include stack traces, which can reveal details about the application's implementation. Stack traces are typically provided by the environment when an application reaches an erroneous state and are used by developers as well as administrators to debug issues. As such, stack traces contain information about all of the open stack frames relating to and leading to the error. They typically include, but are not limited to, function names, parameters, the memory addresses of relevant data, line numbers in code, and class names.\r\n\r\nError messages that contain stack traces reveal application implementation and error condition details to end users. This may include (but is not limited to) information about application architecture and implementation, error conditions, and any third-party libraries in use. In addition, certain languages, such as Java and C#, allow the developer to customize the error messages printed with stack traces. These custom errors may leak additional information since custom errors can include a wide variety of additional information, such as personally identifiable information (PII), connection strings, and request parameters. All this information is useful to an attacker seeking to develop more efficient, targeted attacks against the application.\n\n**References:**\n\n\n* [OWASP: Improper Error Handling](https://owasp.org/www-community/Improper_Error_Handling)\n* [OWASP WSTG: Testing for Improper Error Handling](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/08-Testing_for_Error_Handling/01-Testing_For_Improper_Error_Handling)"
              }
            },
            {
              "id": "A1E0F9376C64CAC59AAB93CD07F1DF27",
              "name": "Stack Trace",
              "fullDescription": {
                "text": "The application generates error messages that include stack traces, which can reveal details about the application's implementation. Stack traces are typically provided by the environment when an application reaches an erroneous state and are used by developers as well as administrators to debug issues. As such, stack traces contain information about all of the open stack frames relating to and leading to the error. They typically include, but are not limited to, function names, parameters, the memory addresses of relevant data, line numbers in code, and class names.\r\n\r\nError messages that contain stack traces reveal application implementation and error condition details to end users. This may include (but is not limited to) information about application architecture and implementation, error conditions, and any third-party libraries in use. In addition, certain languages, such as Java and C#, allow the developer to customize the error messages printed with stack traces. These custom errors may leak additional information since custom errors can include a wide variety of additional information, such as personally identifiable information (PII), connection strings, and request parameters. All this information is useful to an attacker seeking to develop more efficient, targeted attacks against the application.\n\n**References:**\n\n\n* [OWASP: Improper Error Handling](https://owasp.org/www-community/Improper_Error_Handling)\n* [OWASP WSTG: Testing for Improper Error Handling](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/08-Testing_for_Error_Handling/01-Testing_For_Improper_Error_Handling)"
              }
            },
            {
              "id": "C99F0D28B4106F089F0537F4A7C6B484",
              "name": "Stack Trace",
              "fullDescription": {
                "text": "The application generates error messages that include stack traces, which can reveal details about the application's implementation. Stack traces are typically provided by the environment when an application reaches an erroneous state and are used by developers as well as administrators to debug issues. As such, stack traces contain information about all of the open stack frames relating to and leading to the error. They typically include, but are not limited to, function names, parameters, the memory addresses of relevant data, line numbers in code, and class names.\r\n\r\nError messages that contain stack traces reveal application implementation and error condition details to end users. This may include (but is not limited to) information about application architecture and implementation, error conditions, and any third-party libraries in use. In addition, certain languages, such as Java and C#, allow the developer to customize the error messages printed with stack traces. These custom errors may leak additional information since custom errors can include a wide variety of additional information, such as personally identifiable information (PII), connection strings, and request parameters. All this information is useful to an attacker seeking to develop more efficient, targeted attacks against the application.\n\n**References:**\n\n\n* [OWASP: Improper Error Handling](https://owasp.org/www-community/Improper_Error_Handling)\n* [OWASP WSTG: Testing for Improper Error Handling](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/08-Testing_for_Error_Handling/01-Testing_For_Improper_Error_Handling)"
              }
            },
            {
              "id": "6588194600B87D06EB1F710D1DB42C61",
              "name": "Stack Trace",
              "fullDescription": {
                "text": "The application generates error messages that include stack traces, which can reveal details about the application's implementation. Stack traces are typically provided by the environment when an application reaches an erroneous state and are used by developers as well as administrators to debug issues. As such, stack traces contain information about all of the open stack frames relating to and leading to the error. They typically include, but are not limited to, function names, parameters, the memory addresses of relevant data, line numbers in code, and class names.\r\n\r\nError messages that contain stack traces reveal application implementation and error condition details to end users. This may include (but is not limited to) information about application architecture and implementation, error conditions, and any third-party libraries in use. In addition, certain languages, such as Java and C#, allow the developer to customize the error messages printed with stack traces. These custom errors may leak additional information since custom errors can include a wide variety of additional information, such as personally identifiable information (PII), connection strings, and request parameters. All this information is useful to an attacker seeking to develop more efficient, targeted attacks against the application.\n\n**References:**\n\n\n* [OWASP: Improper Error Handling](https://owasp.org/www-community/Improper_Error_Handling)\n* [OWASP WSTG: Testing for Improper Error Handling](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/08-Testing_for_Error_Handling/01-Testing_For_Improper_Error_Handling)"
              }
            },
            {
              "id": "97E4D40C5D6479434C04BA2A19C08B3C",
              "name": "Stack Trace",
              "fullDescription": {
                "text": "The application generates error messages that include stack traces, which can reveal details about the application's implementation. Stack traces are typically provided by the environment when an application reaches an erroneous state and are used by developers as well as administrators to debug issues. As such, stack traces contain information about all of the open stack frames relating to and leading to the error. They typically include, but are not limited to, function names, parameters, the memory addresses of relevant data, line numbers in code, and class names.\r\n\r\nError messages that contain stack traces reveal application implementation and error condition details to end users. This may include (but is not limited to) information about application architecture and implementation, error conditions, and any third-party libraries in use. In addition, certain languages, such as Java and C#, allow the developer to customize the error messages printed with stack traces. These custom errors may leak additional information since custom errors can include a wide variety of additional information, such as personally identifiable information (PII), connection strings, and request parameters. All this information is useful to an attacker seeking to develop more efficient, targeted attacks against the application.\n\n**References:**\n\n\n* [OWASP: Improper Error Handling](https://owasp.org/www-community/Improper_Error_Handling)\n* [OWASP WSTG: Testing for Improper Error Handling](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/08-Testing_for_Error_Handling/01-Testing_For_Improper_Error_Handling)"
              }
            },
            {
              "id": "4AAD3F7AB475946011C75F5ADCE31733",
              "name": "Missing X-Content-Type-Options Header",
              "fullDescription": {
                "text": "The application server does not set the \"X-Content-Type-Options\" header in HTTP responses. The X-Content-Type-Options header mechanism prevents a web browser from overriding the MIME type indicated in the application's Content-Type response header.\n\nMost modern browsers can inspect application responses through \"MIME sniffing\" and determine if the correct Content-Type is specified by the application server. When the X-Content-Type-Options header is specified by an application, browsers will not perform MIME sniffing and will trust the Content-Type specified by the application.\n\nApplications that do not set the X-Content-Type-Options header \"nosniff\" directive explicitly in the application response are more susceptible to MIME Confusion attacks. A MIME confusion attack occurs when an application resource does not provide sufficient metadata to the web browser about the response's content type. In a normal scenario where MIME sniffing is allowed, the web browser sniffs the content of a response to determine which MIME type should be used. Once the web browser has completed its analysis of the response, it compares what is found against the server provided content type header (if present). If the browser detects a mismatched content type, the browser uses the MIME type that it determined on its own.\n\nFor example, consider an application that allows users to upload JPG image files to the server. In this scenario, an attacker may be able to upload a malicious image file where the content of the file is valid HTML or JavaScript. When the uploaded file is returned in the application response, the browser may sniff the content of the malicious file and determine its MIME type to be HTML or JavaScript. When the malicious image file is rendered by the browser, instead of displaying an image, the attacker's malicious HTML or JavaScript is executed.\r\n\r\nEnabled content sniffing makes MIME Confusion attacks possible which, in their turn, lead to cross-site scripting (XSS). Using an XSS, an attacker can arbitrarily alter page content displayed to the victim and can execute application functions using the victim's application identity if the victim is authenticated to the application."
              }
            },
            {
              "id": "85E5F2767445999576FDBD8C3E3A7EB7",
              "name": "Missing CSP",
              "fullDescription": {
                "text": "The application server does not set the Content-Security-Policy (CSP) header in HTTP responses, and therefore does not benefit from the additional protection against potential cross-site scripting issues and other browser-based vulnerabilities that a properly configured CSP may provide. \n\nThe CSP instructs the browser to only load and render trusted resources  specified in the header. A compliant browser will deny loading any resources (such as scripts, images, or objects) not listed in the policy.\n\nCSP has evolved over time and has introduced new security controls. Each introduced control provides improved protection capabilities, here are the fundamental details:\n\n* Level 1 - Initial version, mainly based around allow-list, but proven to be difficult to use securely in practice\n* Level 2 - Introduced  the ability to designate trusted third-party and inline-scripts with a nonce value, rejecting other scripts without the valid nonce\n* Level 3 - Introduced 'strict-dynamic' which enabled easier deployments by dynamically propagating trust from specific root scripts (designated with a nonce or a hash) to any additional scripts loaded by these trusted scripts\n\nCSP allows browsers to differentiate between trusted and untrusted content requested by the page. By default, it also prohibits inline script execution, as well as dynamic script evaluation. A CSP adds an additional line of defense and reduces the overall security risk.\r\n\r\nA missing Content-Security-Policy means that the application will not benefit from the extra protection that it could provide, thereby making the application more vulnerable to exploitation of any existing security issues.\n\n**References:**\n\n\n* [Content Security Policy](https://owasp.org/www-community/controls/Content_Security_Policy)\n* [Content Security Policy Level 2](https://www.w3.org/TR/CSP2/)\n* [Content Security Policy \\(CSP\\)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP)"
              }
            },
            {
              "id": "903816F04E47821D7A8E2834BEB09882",
              "name": "Frameable Resource",
              "fullDescription": {
                "text": "A Frameable Resource is related to a number of vulnerabilities which result from a browser allowing pages to be rendered in a frame. An attacker who can frame a resource within another resource they control may be able to trick the user into acting out of context of the target application. This can be accomplished by hiding the desired UI elements by making them transparent and then using various techniques to induce the desired action from the victim user.\n\nYou should review any resources that are frameable for anything sensitive as they may potentially be vulnerable to a vast array of attacks, including Clickjacking and Cross Site Scripting. Moreover, an attacker can leverage frames to unfold timing and side channel attacks in order to obtain private user data.\r\n\r\n\n\n**References:**\n\n\n* [OWASP: Clickjacking](https://owasp.org/www-community/attacks/Clickjacking)\n* [X-Frame-Options: All about Clickjacking?](https://frederik-braun.com/xfo-clickjacking.pdf)"
              }
            },
            {
              "id": "70F6B68AA2694A62C87777B81946AD3A",
              "name": "Autocomplete Attribute",
              "fullDescription": {
                "text": "The HTML \"autocomplete\" attribute is not set as disabled for sensitive fields. When autocomplete is enabled for a given HTML form field, the browser attempts to fill in a previously stored value as the user enters information. Unique values entered into these fields are cached by the browser for later use.\r\n\r\nAn attacker can retrieve data cached through the browser's autocomplete mechanism via local access to the browser or remote scripting attack. Any sensitive information stored in the browser's autocomplete cache would be exposed. The consequence of exposure differs depending on the type of data cached. An attacker can use exposed passwords to impersonate victims in the application or use a victim's PII (such as social security number, account information, etc.) to steal the victim's identity or gain unauthorized access to their accounts.\n\n**References:**\n\n\n* [Mozilla: The HTML autocomplete attribute](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete)\n* [OWASP Cheat Sheet Series: Credential and Personally Identifiable Information \\(PII\\) Input hints](https://cheatsheetseries.owasp.org/cheatsheets/HTML5_Security_Cheat_Sheet.html#credential-and-personally-identifiable-information-pii-input-hints)"
              }
            },
            {
              "id": "739EC5D13E5C59B3FBBA17AC83B8F600",
              "name": "HTTP Strict Transport Security (HSTS)",
              "fullDescription": {
                "text": "The server does not implement the \"HTTP Strict Transport Security\" (HSTS) web security policy mechanism.\n\nWhen HSTS is enabled, the webserver sends the special HTTP response header called \"Strict-Transport-Security\" to the client. This header includes the max-age attribute, which specifies a duration of time in seconds. Optionally, the directive 'includeSubdomains' can be included to indicate that this policy should apply to all sub-domains as well. After a browser receives this header over a secure HTTPS connection (without any certificate errors), the browser makes new requests to the application over secure HTTPS connections for the duration of time specified in the header. Any links to the server over insecure HTTP connections are automatically rewritten to HTTPS before the request is made. HSTS prevents a user from ignoring certificate errors, as it prevents the user from connecting to a website with an invalid certificate.\r\n\r\nApplications that do not utilize the \"HTTP Strict-Transport-Security\" policy are more susceptible to man-in-the-middle (MITM) attacks via \"SSL stripping\", which occurs when an attacker transparently downgrades a victim's communication with the server from HTTPS to HTTP. Once this is accomplished, the attacker gains the ability to view and potentially modify the victim's traffic, exposing sensitive information, and gaining access to unauthorized functionality.\n\n**References:**\n\n\n* [HTTP Strict Transport Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/HTTP_Strict_Transport_Security_Cheat_Sheet.html)"
              }
            },
            {
              "id": "0E3704165FCC8648225217F64D4B9A5A",
              "name": "Missing Cache Control Header",
              "fullDescription": {
                "text": "The application is not utilizing Cache-Control header, which can lead to sensitive data being cached by the browser.\r\n\r\n"
              }
            },
            {
              "id": "511AAD2FF0458661324C85F0F450D6CB",
              "name": "Directory Search",
              "fullDescription": {
                "text": "An attacker can use Brute Force techniques to search for directories and files, and old backup and configuration files. These resources may store sensitive information about web applications and operational systems, such as source code, credentials, internal network addressing, and so on, thus\nbeing considered a valuable resource for intruders.\r\n\r\n"
              }
            },
            {
              "id": "9D2E183637FABEF0B1ECE9CB55F32CD4",
              "name": "Non-HttpOnly Session Cookie",
              "fullDescription": {
                "text": "The \"HttpOnly\" flag is not set on cookies containing sensitive information. The HttpOnly flag is an attribute set as part of a Set-Cookie header to prevent the cookie's value from being read or set by client-side JavaScript in browsers. Without the HttpOnly attribute, the cookie's value can be accessed by client-side scripts like JavaScript.\r\n\r\nFailing to set the HttpOnly flag on a cookie containing sensitive information will leave it exposed to client-side scripts and could therefore lead to its compromise in the event of a cross-site scripting attack on the application. If a session cookie is missing this flag, it can also make a session compromise easier to perform during a cross-site scripting attack since the attacker can obtain a copy of the session cookie. \n\nNote that the HttpOnly flag is not a protection against session hijacking or cross-site scripting attacks in general, it will only prevent specific attacks that rely on the ability to read cookie values from client-side scripts.\n\n**References:**\n\n\n* [Mitigating Cross-site Scripting With HTTP-only Cookies](https://docs.microsoft.com/en-us/previous-versions//ms533046\\(v=vs.85\\))\n* [HttpOnly](https://owasp.org/www-community/HttpOnly)"
              }
            },
            {
              "id": "F8EEE1909AA630DF92D26506FC6EFA82",
              "name": "Arbitrary Method Allowed",
              "fullDescription": {
                "text": "HTTP offers a number of methods that can be used to perform actions on the web server (the HTTP 1.1 standard refers to them as methods but they are also commonly described as verbs). \n    While GET and POST are by far the most common methods that are used to access information provided by a web server, HTTP allows several other (and somewhat less known) methods. \n    Some of these can be used for nefarious purposes if the web server is misconfigured.\n    Here is a list of unsafe methods:\n    - PUT: This method allows a client to upload new files on the web server. An attacker can exploit it by uploading malicious files (e.g.: an asp file that executes commands by invoking cmd.exe), or by simply using the victim\u2019s server as a file repository.\n    - DELETE: This method allows a client to delete a file on the web server. An attacker can exploit it as a very simple and direct way to deface a web site or to mount a denial-of-service (DoS) attack.\n    - CONNECT: This method could allow a client to use the web server as a proxy.\n    - TRACE: This method simply echoes back to the client whatever string has been sent to the server, and is used mainly for debugging purposes. This method, originally assumed harmless, can be used to mount an attack known as Cross Site Tracing.\n    - HEAD: This method behaves like a GET request, but only returns the response headers. An attacker can exploit this to bypass access control mechanisms. \n    Many frameworks and languages treat \"HEAD\" as a \"GET\" request, albeit one without any body in the response. If a security constraint was set on \"GET\" requests such that only \"authenticatedUsers\" could access GET requests for a particular servlet or resource, it would be bypassed for the \"HEAD\" version. This allowed unauthorized blind submission of any privileged GET request.\n    Some frameworks allowed arbitrary HTTP methods such as \"JEFF\" or \"CATS\" to be used without limitation. These were treated as if a \"GET\" method was issued, and were found not to be subject to method role based access control checks on a number of languages and frameworks, again allowing unauthorized blind submission of privileged GET requests.\r\n\r\n\n\n**References:**\n\n\n* [OWASP WSTG: Test HTTP Methods](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/02-Configuration_and_Deployment_Management_Testing/06-Test_HTTP_Methods)\n* [Bypassing Web Authentication and Authorization with HTTP Verb Tampering](https://dl.packetstormsecurity.net/papers/web/Bypassing_VBAAC_with_HTTP_Verb_Tampering.pdf)"
              }
            },
            {
              "id": "FC5979F6711BD1F140195855827067AD",
              "name": "Password Disclosure",
              "fullDescription": {
                "text": "The application sends the user's password in an HTTP response. Including the password in application responses increases the likelihood of password compromise.\r\n\r\nAn attacker performing a man-in-the-middle attack may be able to capture the password during a non-login request, increasing the likelihood that they capture the password. HTTP responses may be cached locally by the user, allowing an attacker with access (remote or physical) to the machine to recover the password. Once the attacker has the password, they would be able to masquerade as the user in the application.\n\n**References:**\n\n\n* [OWASP WSTG: Review Webpage Content for Information Leakage](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/01-Information_Gathering/05-Review_Webpage_Content_for_Information_Leakage)"
              }
            }
          ]
        }
      },
      "artifacts": [
        {
          "location": {
            "uri": "POLARIS",
            "uriBaseId": "SRCROOT"
          },
          "sourceLanguage": "python"
        }
      ],
      "results": [
        {
          "ruleId": "8659F9303BF3A26B84B2125B88AB7E15",
          "ruleIndex": 0,
          "message": {
            "text": "Server Error"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "POLARIS",
                  "uriBaseId": "SRCROOT",
                  "index": 0
                },
                "region": {
                  "startLine": 1
                }
              }
            }
          ]
        },
        {
          "ruleId": "5387BD05073049EE934D84458C86FACE",
          "ruleIndex": 1,
          "message": {
            "text": "Server Error"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "POLARIS",
                  "uriBaseId": "SRCROOT",
                  "index": 0
                },
                "region": {
                  "startLine": 1
                }
              }
            }
          ]
        },
        {
          "ruleId": "FF9BABE97447B17D042D69FABAB72F98",
          "ruleIndex": 2,
          "message": {
            "text": "Server Error"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "POLARIS",
                  "uriBaseId": "SRCROOT",
                  "index": 0
                },
                "region": {
                  "startLine": 1
                }
              }
            }
          ]
        },
        {
          "ruleId": "46E6C6A03B55651B27596E1C842ED038",
          "ruleIndex": 3,
          "message": {
            "text": "Server Error"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "POLARIS",
                  "uriBaseId": "SRCROOT",
                  "index": 0
                },
                "region": {
                  "startLine": 1
                }
              }
            }
          ]
        },
        {
          "ruleId": "2FC5500043A886DBF8B1B080CCC44840",
          "ruleIndex": 4,
          "message": {
            "text": "Server Error"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "POLARIS",
                  "uriBaseId": "SRCROOT",
                  "index": 0
                },
                "region": {
                  "startLine": 1
                }
              }
            }
          ]
        },
        {
          "ruleId": "CCF5F89C41264FC7E6B90B93478BC8F0",
          "ruleIndex": 5,
          "message": {
            "text": "Server Error"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "POLARIS",
                  "uriBaseId": "SRCROOT",
                  "index": 0
                },
                "region": {
                  "startLine": 1
                }
              }
            }
          ]
        },
        {
          "ruleId": "BC00609D0BE528FC84DDD93E823A0FC8",
          "ruleIndex": 6,
          "message": {
            "text": "Server Error"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "POLARIS",
                  "uriBaseId": "SRCROOT",
                  "index": 0
                },
                "region": {
                  "startLine": 1
                }
              }
            }
          ]
        },
        {
          "ruleId": "737CCF4C6EB5A0AA41041ED8A67594BE",
          "ruleIndex": 7,
          "message": {
            "text": "Server Error"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "POLARIS",
                  "uriBaseId": "SRCROOT",
                  "index": 0
                },
                "region": {
                  "startLine": 1
                }
              }
            }
          ]
        },
        {
          "ruleId": "49502AD3CBA2EBFE782B08B5DFCD523B",
          "ruleIndex": 8,
          "message": {
            "text": "Server Error"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "POLARIS",
                  "uriBaseId": "SRCROOT",
                  "index": 0
                },
                "region": {
                  "startLine": 1
                }
              }
            }
          ]
        },
        {
          "ruleId": "461F27419D71D8D4054D4647D01C82B1",
          "ruleIndex": 9,
          "message": {
            "text": "Server Error"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "POLARIS",
                  "uriBaseId": "SRCROOT",
                  "index": 0
                },
                "region": {
                  "startLine": 1
                }
              }
            }
          ]
        },
        {
          "ruleId": "A241AF41BB63C7D95A0CA2C6334EA4E7",
          "ruleIndex": 10,
          "message": {
            "text": "Server Error"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "POLARIS",
                  "uriBaseId": "SRCROOT",
                  "index": 0
                },
                "region": {
                  "startLine": 1
                }
              }
            }
          ]
        },
        {
          "ruleId": "94F6BE4EC7EBBF0BDF36FEB351AA1E80",
          "ruleIndex": 11,
          "message": {
            "text": "Unsecured Session Cookie"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "POLARIS",
                  "uriBaseId": "SRCROOT",
                  "index": 0
                },
                "region": {
                  "startLine": 1
                }
              }
            }
          ]
        },
        {
          "ruleId": "133F8F76E8634046ABA74703C85D3FFD",
          "ruleIndex": 12,
          "message": {
            "text": "Stack Trace"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "POLARIS",
                  "uriBaseId": "SRCROOT",
                  "index": 0
                },
                "region": {
                  "startLine": 1
                }
              }
            }
          ]
        },
        {
          "ruleId": "334C00D2DF14756377256A0990249A24",
          "ruleIndex": 13,
          "message": {
            "text": "Stack Trace"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "POLARIS",
                  "uriBaseId": "SRCROOT",
                  "index": 0
                },
                "region": {
                  "startLine": 1
                }
              }
            }
          ]
        },
        {
          "ruleId": "F3585F038F1CD7E175C560C461A89584",
          "ruleIndex": 14,
          "message": {
            "text": "Stack Trace"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "POLARIS",
                  "uriBaseId": "SRCROOT",
                  "index": 0
                },
                "region": {
                  "startLine": 1
                }
              }
            }
          ]
        },
        {
          "ruleId": "2547662566BA8B63EE673062D14971CC",
          "ruleIndex": 15,
          "message": {
            "text": "Stack Trace"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "POLARIS",
                  "uriBaseId": "SRCROOT",
                  "index": 0
                },
                "region": {
                  "startLine": 1
                }
              }
            }
          ]
        },
        {
          "ruleId": "7B0E93A5E9883BE9BC15BA87AEB25B1B",
          "ruleIndex": 16,
          "message": {
            "text": "Stack Trace"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "POLARIS",
                  "uriBaseId": "SRCROOT",
                  "index": 0
                },
                "region": {
                  "startLine": 1
                }
              }
            }
          ]
        },
        {
          "ruleId": "9231792F8ECE81D8B78F7A09DFA96F3D",
          "ruleIndex": 17,
          "message": {
            "text": "Stack Trace"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "POLARIS",
                  "uriBaseId": "SRCROOT",
                  "index": 0
                },
                "region": {
                  "startLine": 1
                }
              }
            }
          ]
        },
        {
          "ruleId": "7BA471E8EF7FC63AFF751C76CCFC53FA",
          "ruleIndex": 18,
          "message": {
            "text": "Stack Trace"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "POLARIS",
                  "uriBaseId": "SRCROOT",
                  "index": 0
                },
                "region": {
                  "startLine": 1
                }
              }
            }
          ]
        },
        {
          "ruleId": "944A936F1301AD0362E35CFC80912D37",
          "ruleIndex": 19,
          "message": {
            "text": "Stack Trace"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "POLARIS",
                  "uriBaseId": "SRCROOT",
                  "index": 0
                },
                "region": {
                  "startLine": 1
                }
              }
            }
          ]
        },
        {
          "ruleId": "E2FFF487F311D91C720DB1BD8D127606",
          "ruleIndex": 20,
          "message": {
            "text": "Stack Trace"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "POLARIS",
                  "uriBaseId": "SRCROOT",
                  "index": 0
                },
                "region": {
                  "startLine": 1
                }
              }
            }
          ]
        },
        {
          "ruleId": "9995B9A075EB74E42F5D3D7CACA57B66",
          "ruleIndex": 21,
          "message": {
            "text": "Stack Trace"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "POLARIS",
                  "uriBaseId": "SRCROOT",
                  "index": 0
                },
                "region": {
                  "startLine": 1
                }
              }
            }
          ]
        },
        {
          "ruleId": "17FAAABBDCA4CF51EB3672F162980566",
          "ruleIndex": 22,
          "message": {
            "text": "Stack Trace"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "POLARIS",
                  "uriBaseId": "SRCROOT",
                  "index": 0
                },
                "region": {
                  "startLine": 1
                }
              }
            }
          ]
        },
        {
          "ruleId": "A1E0F9376C64CAC59AAB93CD07F1DF27",
          "ruleIndex": 23,
          "message": {
            "text": "Stack Trace"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "POLARIS",
                  "uriBaseId": "SRCROOT",
                  "index": 0
                },
                "region": {
                  "startLine": 1
                }
              }
            }
          ]
        },
        {
          "ruleId": "C99F0D28B4106F089F0537F4A7C6B484",
          "ruleIndex": 24,
          "message": {
            "text": "Stack Trace"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "POLARIS",
                  "uriBaseId": "SRCROOT",
                  "index": 0
                },
                "region": {
                  "startLine": 1
                }
              }
            }
          ]
        },
        {
          "ruleId": "6588194600B87D06EB1F710D1DB42C61",
          "ruleIndex": 25,
          "message": {
            "text": "Stack Trace"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "POLARIS",
                  "uriBaseId": "SRCROOT",
                  "index": 0
                },
                "region": {
                  "startLine": 1
                }
              }
            }
          ]
        },
        {
          "ruleId": "97E4D40C5D6479434C04BA2A19C08B3C",
          "ruleIndex": 26,
          "message": {
            "text": "Stack Trace"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "POLARIS",
                  "uriBaseId": "SRCROOT",
                  "index": 0
                },
                "region": {
                  "startLine": 1
                }
              }
            }
          ]
        },
        {
          "ruleId": "4AAD3F7AB475946011C75F5ADCE31733",
          "ruleIndex": 27,
          "message": {
            "text": "Missing X-Content-Type-Options Header"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "POLARIS",
                  "uriBaseId": "SRCROOT",
                  "index": 0
                },
                "region": {
                  "startLine": 1
                }
              }
            }
          ]
        },
        {
          "ruleId": "85E5F2767445999576FDBD8C3E3A7EB7",
          "ruleIndex": 28,
          "message": {
            "text": "Missing CSP"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "POLARIS",
                  "uriBaseId": "SRCROOT",
                  "index": 0
                },
                "region": {
                  "startLine": 1
                }
              }
            }
          ]
        },
        {
          "ruleId": "903816F04E47821D7A8E2834BEB09882",
          "ruleIndex": 29,
          "message": {
            "text": "Frameable Resource"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "POLARIS",
                  "uriBaseId": "SRCROOT",
                  "index": 0
                },
                "region": {
                  "startLine": 1
                }
              }
            }
          ]
        },
        {
          "ruleId": "70F6B68AA2694A62C87777B81946AD3A",
          "ruleIndex": 30,
          "message": {
            "text": "Autocomplete Attribute"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "POLARIS",
                  "uriBaseId": "SRCROOT",
                  "index": 0
                },
                "region": {
                  "startLine": 1
                }
              }
            }
          ]
        },
        {
          "ruleId": "739EC5D13E5C59B3FBBA17AC83B8F600",
          "ruleIndex": 31,
          "message": {
            "text": "HTTP Strict Transport Security (HSTS)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "POLARIS",
                  "uriBaseId": "SRCROOT",
                  "index": 0
                },
                "region": {
                  "startLine": 1
                }
              }
            }
          ]
        },
        {
          "ruleId": "0E3704165FCC8648225217F64D4B9A5A",
          "ruleIndex": 32,
          "message": {
            "text": "Missing Cache Control Header"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "POLARIS",
                  "uriBaseId": "SRCROOT",
                  "index": 0
                },
                "region": {
                  "startLine": 1
                }
              }
            }
          ]
        },
        {
          "ruleId": "511AAD2FF0458661324C85F0F450D6CB",
          "ruleIndex": 33,
          "message": {
            "text": "Directory Search"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "POLARIS",
                  "uriBaseId": "SRCROOT",
                  "index": 0
                },
                "region": {
                  "startLine": 1
                }
              }
            }
          ]
        },
        {
          "ruleId": "9D2E183637FABEF0B1ECE9CB55F32CD4",
          "ruleIndex": 34,
          "message": {
            "text": "Non-HttpOnly Session Cookie"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "POLARIS",
                  "uriBaseId": "SRCROOT",
                  "index": 0
                },
                "region": {
                  "startLine": 1
                }
              }
            }
          ]
        },
        {
          "ruleId": "F8EEE1909AA630DF92D26506FC6EFA82",
          "ruleIndex": 35,
          "message": {
            "text": "Arbitrary Method Allowed"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "POLARIS",
                  "uriBaseId": "SRCROOT",
                  "index": 0
                },
                "region": {
                  "startLine": 1
                }
              }
            }
          ]
        },
        {
          "ruleId": "FC5979F6711BD1F140195855827067AD",
          "ruleIndex": 36,
          "message": {
            "text": "Password Disclosure"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "POLARIS",
                  "uriBaseId": "SRCROOT",
                  "index": 0
                },
                "region": {
                  "startLine": 1
                }
              }
            }
          ]
        }
      ]
    }
  ]
}